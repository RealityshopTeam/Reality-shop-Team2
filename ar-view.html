<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Reality Shop - Universal Fake AR</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
    #cameraFeed, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .instructions {
      position: absolute; bottom: 10px; width: 100%;
      text-align: center; color: white;
      font-size: 1rem; font-weight: bold;
      background: rgba(0,0,0,0.5); padding: 6px;
    }
  </style>
</head>
<body>
  <video id="cameraFeed" autoplay playsinline muted></video>
  <canvas id="threeCanvas"></canvas>
  <div class="instructions">üëÜ Tap to place, ‚úã drag to move, ü§è pinch to scale</div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    const video = document.getElementById("cameraFeed");
    const canvas = document.getElementById("threeCanvas");

    // Setup camera feed
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
      .then(stream => { video.srcObject = stream; })
      .catch(err => console.error("Camera error:", err));

    // Three.js scene
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
    camera.position.z = 2;

    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    scene.add(light);

    // Load furniture model
    const loader = new THREE.GLTFLoader();
    let modelObj;
    loader.load("chair.glb", gltf => {
      modelObj = gltf.scene;
      modelObj.scale.set(0.5, 0.5, 0.5);
      modelObj.visible = false; // only show after tap
      scene.add(modelObj);
    });

    // --- Gestures ---
    let dragging = false, lastX = 0, lastY = 0;
    let startDistance = 0, startScale = 1;

    function getDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx*dx + dy*dy);
    }

    canvas.addEventListener("touchstart", e => {
      if (e.touches.length === 1) {
        // Tap to place
        if (modelObj) {
          modelObj.visible = true;
          modelObj.position.set(0, -0.5, -2); // in front of camera
        }
        dragging = true;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      } else if (e.touches.length === 2 && modelObj) {
        startDistance = getDistance(e.touches);
        startScale = modelObj.scale.x;
      }
    });

    canvas.addEventListener("touchmove", e => {
      if (dragging && e.touches.length === 1 && modelObj) {
        const dx = (e.touches[0].clientX - lastX) / 200;
        const dy = (e.touches[0].clientY - lastY) / 200;
        modelObj.position.x += dx;
        modelObj.position.y -= dy;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      } else if (e.touches.length === 2 && modelObj) {
        const newDist = getDistance(e.touches);
        const scaleFactor = newDist / startDistance;
        modelObj.scale.setScalar(startScale * scaleFactor);
      }
    });

    canvas.addEventListener("touchend", e => { dragging = false; });

    // Mouse support for PC
    canvas.addEventListener("mousedown", e => {
      if (modelObj) modelObj.visible = true;
      dragging = true; lastX = e.clientX; lastY = e.clientY;
    });
    canvas.addEventListener("mousemove", e => {
      if (dragging && modelObj) {
        const dx = (e.clientX - lastX) / 100;
        const dy = (e.clientY - lastY) / 100;
        modelObj.position.x += dx;
        modelObj.position.y -= dy;
        lastX = e.clientX; lastY = e.clientY;
      }
    });
    canvas.addEventListener("mouseup", () => { dragging = false; });
    canvas.addEventListener("wheel", e => {
      if (modelObj) {
        const s = modelObj.scale.x * (1 - e.deltaY * 0.001);
        modelObj.scale.setScalar(Math.max(0.1, s));
      }
    });

    // Render loop
    function animate() {
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
