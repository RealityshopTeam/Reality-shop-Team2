<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Reality Shop - Universal AR</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
    #cameraFeed, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .instructions {
      position: absolute; bottom: 10px; width: 100%;
      text-align: center; color: white;
      font-size: 1rem; font-weight: bold;
      background: rgba(0,0,0,0.5); padding: 6px;
    }
  </style>
</head>
<body>
  <video id="cameraFeed" autoplay playsinline muted></video>
  <canvas id="threeCanvas"></canvas>
  <div class="instructions">üëÜ Tap/Click to place, ‚úã drag to move, ü§è pinch/scroll to scale</div>

  <!-- Three.js as ES module -->
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

    const video = document.getElementById("cameraFeed");
    const canvas = document.getElementById("threeCanvas");

    // Setup camera feed
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
      .then(stream => { video.srcObject = stream; })
      .catch(err => console.error("Camera error:", err));

    // Three.js scene setup
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
    camera.position.z = 2;

    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    scene.add(light);

    // ---- LOAD PRODUCT MODEL ----
    const loader = new GLTFLoader();
    let modelObj;

    // ‚úÖ Make sure imgs/chair.glb exists relative to this HTML file
    loader.load(
      "./imgs/chair.glb",
      gltf => {
        modelObj = gltf.scene;
        modelObj.scale.set(0.5, 0.5, 0.5);
        modelObj.position.set(0, -0.5, -2);
        scene.add(modelObj);
        console.log("‚úÖ Product loaded successfully");
      },
      xhr => console.log(`Loading: ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`),
      error => {
        console.error("‚ùå Failed to load product:", error);
        // fallback cube
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const material = new THREE.MeshNormalMaterial();
        modelObj = new THREE.Mesh(geometry, material);
        modelObj.position.set(0, -0.5, -2);
        scene.add(modelObj);
      }
    );

    // --- Gestures ---
    let dragging = false, lastX = 0, lastY = 0;
    let startDistance = 0, startScale = 1;

    function getDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx*dx + dy*dy);
    }

    canvas.addEventListener("touchstart", e => {
      if (!modelObj) return;
      if (e.touches.length === 1) {
        dragging = true;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        startDistance = getDistance(e.touches);
        startScale = modelObj.scale.x;
      }
    });

    canvas.addEventListener("touchmove", e => {
      if (!modelObj) return;
      if (dragging && e.touches.length === 1) {
        const dx = (e.touches[0].clientX - lastX) / 200;
        const dy = (e.touches[0].clientY - lastY) / 200;
        modelObj.position.x += dx;
        modelObj.position.y -= dy;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        const newDist = getDistance(e.touches);
        const scaleFactor = newDist / startDistance;
        modelObj.scale.setScalar(startScale * scaleFactor);
      }
    });

    canvas.addEventListener("touchend", () => { dragging = false; });

    canvas.addEventListener("mousedown", e => {
      dragging = true; lastX = e.clientX; lastY = e.clientY;
    });
    canvas.addEventListener("mousemove", e => {
      if (dragging && modelObj) {
        const dx = (e.clientX - lastX) / 100;
        const dy = (e.clientY - lastY) / 100;
        modelObj.position.x += dx;
        modelObj.position.y -= dy;
        lastX = e.clientX; lastY = e.clientY;
      }
    });
    canvas.addEventListener("mouseup", () => { dragging = false; });

    canvas.addEventListener("wheel", e => {
      if (modelObj) {
        const s = modelObj.scale.x * (1 - e.deltaY * 0.001);
        modelObj.scale.setScalar(Math.max(0.1, s));
      }
    });

    // Render loop
    function animate() {
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
