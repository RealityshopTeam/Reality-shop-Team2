<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Selfie â†’ Avatar (No AI)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --pad: 12px; }
    body {
      margin: 0; font-family: system-ui, Arial, sans-serif; background: linear-gradient(135deg,#0b0d10 0%, #1c1f26 100%); color:#e9eef3;
      display:flex; flex-direction:column; min-height:100dvh;
      scroll-behavior: smooth;
    }
    nav {
      background-color: #212121;
      box-shadow: 0 2px 8px rgba(0,0,0,0.5);
      position: fixed;
      width: 100%;
      top: 0;
      left: 0;
      z-index: 100;
    }
    .nav-container {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 60px;
      padding: 0 16px;
    }
    .logo {
      color: #ff9800;
      font-weight: 700;
      font-size: 1.6rem;
      letter-spacing: 2px;
      text-decoration: none;
    }
    ul.nav-links {
      display: flex;
      list-style: none;
      gap: 24px;
      margin: 0;
      padding: 0;
    }
    ul.nav-links a {
      color: #eee;
      text-decoration: none;
      font-size: 1rem;
      padding: 6px 8px;
      border-radius: 8px;
      transition: background-color 0.2s;
    }
    ul.nav-links a:hover, ul.nav-links a.active {
      background-color: #ff9800;
      color: #212121;
    }

    main {
      display: grid;
      grid-template-columns: 1fr 340px;
      gap: 16px;
      padding: 80px 16px 16px;
      flex: 1;
      max-width: 1200px;
      margin: 0 auto;
      width: 100%;
      box-sizing: border-box;
    }
    #viewer {
      background: #0f1318;
      border: 1px solid #1b2026;
      border-radius: 16px;
      min-height: 60dvh;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    #controls {
      background: #0f1318;
      border: 1px solid #1b2026;
      border-radius: 16px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      color: #ccc;
      font-size: 14px;
    }
    .row {
      display: flex; align-items: center; gap: 10px;
    }
    .row input[type="color"] {
      width: 48px;
      height: 36px;
      border: none;
      background: transparent;
      cursor: pointer;
    }
    .hint {
      font-size: 12px;
      color: #9aa7b3;
    }
    button, label.btn {
      background:#1e2630;
      color:#e9eef3;
      border:1px solid #2a3542;
      padding:8px 12px;
      border-radius:10px;
      cursor:pointer;
      transition: transform .06s ease, background .2s ease;
      user-select:none;
    }
    button:hover, label.btn:hover {
      background:#222c39;
    }
    button:active, label.btn:active {
      transform: translateY(1px);
    }
    #selfieCanvas {
      display:none;
    }
    .grid {
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .sep {
      height:1px;
      background:#1b2026;
      margin:6px 0;
    }
    code {
      background:#0b0f14;
      padding:2px 6px;
      border-radius:6px;
      border:1px solid #161b21;
      user-select:text;
    }
    @media (max-width: 980px) {
      main {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  
  <nav>
    <div class="nav-container">
      <a href="index.html" class="logo">Reality Shop</a>
      <ul class="nav-links">
        <li><a href="index.html">Home</a></li>
        <li><a href="shop.html">Shop</a></li>
        <li><a href="wishlist.html">Wishlist</a></li>
        <li><a href="cart.html">Cart</a></li>
        <li><a href="contact.html">Contact</a></li>
        <li><a href="about.html">About</a></li>
        <li><a href="login.html">Account</a></li>
      </ul>
    </div>
  </nav>

  <main>
    <div id="viewer"></div>

    <aside id="controls">
      <div class="row" style="justify-content:space-between;">
        <div>
          <strong>1) Upload selfie</strong>
          <div class="hint">Frontal face, good light. JPG/PNG.</div>
        </div>
        <label class="btn" for="selfieInput">Choose file</label>
        <input id="selfieInput" type="file" accept="image/*" style="display:none;" />
      </div>

      <canvas id="selfieCanvas" width="512" height="512"></canvas>

      <div class="sep"></div>

      <div><strong>2) Detected colors</strong> <span class="hint">(you can tweak)</span></div>
      <div class="grid">
        <div>
          <div class="row">
            <label for="skinColor">Skin</label>
            <input id="skinColor" type="color" value="#f2d3c2" />
          </div>
          <div class="hint">Auto from central face region.</div>
        </div>
        <div>
          <div class="row">
            <label for="hairColor">Hair</label>
            <input id="hairColor" type="color" value="#3a2a20" />
          </div>
          <div class="hint">Auto from top band (darkest tones).</div>
        </div>
      </div>

      <div class="row">
        <button id="applyBtn">Apply to Avatar</button>
        <button id="resetBtn" title="Reload model">Reset</button>
      </div>

      <div class="sep"></div>

      <div>
        <strong>Material mapping</strong>
        <div class="hint">
          The code looks for materials named <code>Skin</code> and <code>Hair</code>.  
          Update your GLB or change names in the code if needed.
        </div>
      </div>

      <div class="sep"></div>

      <div>
        <strong>Rotate & zoom</strong>
        <div class="hint">Use mouse drag / wheel. Shift+drag to pan.</div>
      </div>
    </aside>
  </main>

  <footer style="padding:12px 16px; border-top:1px solid #1b2026; text-align:center;">
    <span class="hint">Tip: For best results, use a clear, well-lit selfie. Glasses/hats can bias hair detection.</span>
  </footer>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    const viewer = document.getElementById('viewer');
    const selfieInput = document.getElementById('selfieInput');
    const canvas = document.getElementById('selfieCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const skinColorInput = document.getElementById('skinColor');
    const hairColorInput = document.getElementById('hairColor');
    const applyBtn = document.getElementById('applyBtn');
    const resetBtn = document.getElementById('resetBtn');

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(viewer.clientWidth, Math.max(viewer.clientHeight, 480));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    viewer.appendChild(renderer.domElement);

    // Scene, Camera, Controls
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, viewer.clientWidth / Math.max(viewer.clientHeight, 480), 0.1, 100);
    camera.position.set(0, 1.5, 3.2);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lighting
    const hemi = new THREE.HemisphereLight(0xffffff, 0x445566, 0.8);
    scene.add(hemi);
    const key = new THREE.DirectionalLight(0xffffff, 1);
    key.position.set(2, 4, 3);
    scene.add(key);
    const rim = new THREE.DirectionalLight(0xffffff, 0.5);
    rim.position.set(-2, 3, -3);
    scene.add(rim);

    // Ground
    const ground = new THREE.Mesh(
      new THREE.CircleGeometry(5, 64),
      new THREE.MeshStandardMaterial({ color: 0x0c1116, metalness: 0, roughness: 1 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    // Load Avatar model
    const loader = new GLTFLoader();
    let avatarRoot = null;
    const MODEL_URL = 'baseAvatar.glb';

    async function loadModel() {
      if (avatarRoot) {
        scene.remove(avatarRoot);
        avatarRoot = null;
      }
      const gltf = await loader.loadAsync(MODEL_URL);
      avatarRoot = gltf.scene;
      avatarRoot.traverse(obj => {
        if (obj.isMesh) {
          obj.castShadow = true;
          obj.receiveShadow = true;
          if (!(obj.material instanceof THREE.MeshStandardMaterial)) {
            obj.material = new THREE.MeshStandardMaterial({ color: obj.material?.color || 0xffffff });
          }
        }
      });

      // Center and scale
      const box = new THREE.Box3().setFromObject(avatarRoot);
      const size = new THREE.Vector3();
      box.getSize(size);
      const center = new THREE.Vector3();
      box.getCenter(center);

      const scale = 1.6 / Math.max(size.x, size.y, size.z);
      avatarRoot.scale.setScalar(scale);
      avatarRoot.position.sub(center.multiplyScalar(scale));
      avatarRoot.position.y = 0;
      scene.add(avatarRoot);
    }

    function rgbToHex(r, g, b) {
      return "#" + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function hexToThreeColor(hex) {
      return new THREE.Color(hex);
    }

    function clamp(v, min, max) {
      return Math.min(Math.max(v, min), max);
    }

    function averageRegion(imgData, region) {
      const { data, width, height } = imgData;
      const { x, y, w, h, type } = region;
      const cx = x + w / 2, cy = y + h / 2;
      const rx = w / 2, ry = h / 2;
      const values = [];
      for (let j = Math.max(0, y); j < Math.min(height, y + h); j++) {
        for (let i = Math.max(0, x); i < Math.min(width, x + w); i++) {
          const dx = (i - cx) / rx;
          const dy = (j - cy) / ry;
          if (dx * dx + dy * dy > 1) continue;
          const idx = (j * width + i) * 4;
          const r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];
          if (a < 10) continue;
          const luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
          if (type === 'skin') {
            if (luma < 40 || luma > 240) continue;
            if (!(r > 80 && g > 40 && b > 20)) continue;
          } else if (type === 'hair') {
            if (luma > 160) continue;
          }
          values.push([r, g, b]);
        }
      }
      if (!values.length) return type === 'skin' ? [242, 211, 194] : [58, 42, 32];
      const lum = values.map(([r, g, b]) => 0.2126 * r + 0.7152 * g + 0.0722 * b).sort((a, b) => a - b);
      const lo = lum[Math.floor(lum.length * 0.1)];
      const hi = lum[Math.floor(lum.length * 0.9)];
      let R = 0, G = 0, B = 0, n = 0;
      for (const [r, g, b] of values) {
        const L = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        if (L < lo || L > hi) continue;
        R += r; G += g; B += b; n++;
      }
      return n === 0 ? values[0] : [Math.round(R / n), Math.round(G / n), Math.round(B / n)];
    }

    async function estimateColorsFromSelfie(file) {
      const img = new Image();
      const url = URL.createObjectURL(file);
      await new Promise((res, rej) => {
        img.onload = () => res();
        img.onerror = () => rej();
        img.src = url;
      });

      const S = canvas.width;
      const scale = Math.max(S / img.width, S / img.height);
      const w = Math.round(img.width * scale);
      const h = Math.round(img.height * scale);
      const ox = Math.round((S - w) / 2);
      const oy = Math.round((S - h) / 2);
      ctx.clearRect(0, 0, S, S);
      ctx.drawImage(img, ox, oy, w, h);
      const imgData = ctx.getImageData(0, 0, S, S);

      const skinRegion = { x: Math.round(S * 0.20), y: Math.round(S * 0.15), w: Math.round(S * 0.60), h: Math.round(S * 0.70), type: 'skin' };
      const hairRegion = { x: Math.round(S * 0.10), y: Math.round(S * 0.02), w: Math.round(S * 0.80), h: Math.round(S * 0.28), type: 'hair' };

      const [sr, sg, sb] = averageRegion(imgData, skinRegion);
      const [hr, hg, hb] = averageRegion(imgData, hairRegion);

      const skinHex = rgbToHex(clamp(sr, 40, 245), clamp(sg, 30, 235), clamp(sb, 30, 230));
      const hairHex = rgbToHex(clamp(hr, 10, 110), clamp(hg, 10, 110), clamp(hb, 10, 110));

      skinColorInput.value = skinHex;
      hairColorInput.value = hairHex;

      URL.revokeObjectURL(url);
      return { skinHex, hairHex };
    }

    function applyColorsToAvatar(skinHex, hairHex) {
      if (!avatarRoot) return;
      let appliedSkin = 0, appliedHair = 0;
      avatarRoot.traverse(obj => {
        if (obj.isMesh && obj.material) {
          const name = (obj.material.name || obj.name || '').toLowerCase();
          if (name.includes('skin')) {
            obj.material.color = hexToThreeColor(skinHex);
            obj.material.needsUpdate = true;
            appliedSkin++;
          } else if (name.includes('hair')) {
            obj.material.color = hexToThreeColor(hairHex);
            obj.material.needsUpdate = true;
            appliedHair++;
          }
        }
      });
      if (appliedSkin + appliedHair === 0) {
        alert('No materials named "Skin" or "Hair" found. Please rename materials accordingly.');
      }
    }

    selfieInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        await estimateColorsFromSelfie(file);
      } catch {
        alert('Failed to load selfie. Please try another image.');
      }
    });

    applyBtn.addEventListener('click', () => {
      applyColorsToAvatar(skinColorInput.value, hairColorInput.value);
    });

    resetBtn.addEventListener('click', async () => {
      await loadModel();
    });

    window.addEventListener('resize', () => {
      const w = viewer.clientWidth;
      const h = Math.max(viewer.clientHeight, 480);
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    });

    renderer.setAnimationLoop(() => {
      controls.update();
      renderer.render(scene, camera);
    });

    await loadModel();
    window.dispatchEvent(new Event('resize'));
  </script>
</body>
</html>
