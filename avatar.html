<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Selfie → Avatar (No AI)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --pad: 12px; }
    body {
      margin: 0; font-family: system-ui, Arial, sans-serif; background:#0b0d10; color:#e9eef3;
      display:flex; flex-direction:column; min-height:100dvh;
    }
    header { padding: var(--pad) calc(var(--pad) * 2); border-bottom:1px solid #1b2026; }
    main { display:grid; grid-template-columns: 1fr 340px; gap: 16px; padding: 16px; flex:1; }
    #viewer { background:#0f1318; border:1px solid #1b2026; border-radius:16px; min-height:60dvh; display:flex; align-items:center; justify-content:center; }
    #controls { background:#0f1318; border:1px solid #1b2026; border-radius:16px; padding: 16px; display:flex; flex-direction:column; gap:12px; }
    .row { display:flex; align-items:center; gap:10px; }
    .row input[type="color"] { width: 48px; height: 36px; border: none; background: transparent; }
    .hint { font-size: 12px; color:#9aa7b3; }
    button, label.btn {
      background:#1e2630; color:#e9eef3; border:1px solid #2a3542; padding:8px 12px; border-radius:10px;
      cursor:pointer; transition: transform .06s ease, background .2s ease;
    }
    button:hover, label.btn:hover { background:#222c39; }
    button:active, label.btn:active { transform: translateY(1px); }
    #selfieCanvas { display:none; }
    .swatch { width:16px; height:16px; border-radius:4px; border:1px solid #2a3542; display:inline-block; vertical-align:middle; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .sep { height:1px; background:#1b2026; margin:6px 0; }
    code { background:#0b0f14; padding:2px 6px; border-radius:6px; border:1px solid #161b21; }
    @media (max-width: 980px){ main { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <header>
    <h2>Selfie → Avatar (No AI / No External APIs)</h2>
    <div class="hint">Upload a selfie. We estimate skin & hair colors client-side and apply them to your GLB avatar.</div>
  </header>

  <main>
    <div id="viewer"></div>

    <aside id="controls">
      <div class="row" style="justify-content:space-between;">
        <div>
          <strong>1) Upload selfie</strong>
          <div class="hint">Frontal face, good light. JPG/PNG.</div>
        </div>
        <label class="btn" for="selfieInput">Choose file</label>
        <input id="selfieInput" type="file" accept="image/*" style="display:none;" />
      </div>

      <canvas id="selfieCanvas" width="512" height="512"></canvas>

      <div class="sep"></div>

      <div><strong>2) Detected colors</strong> <span class="hint">(you can tweak)</span></div>
      <div class="grid">
        <div>
          <div class="row">
            <label for="skinColor">Skin</label>
            <input id="skinColor" type="color" value="#f2d3c2" />
          </div>
          <div class="hint">Auto from central face region.</div>
        </div>
        <div>
          <div class="row">
            <label for="hairColor">Hair</label>
            <input id="hairColor" type="color" value="#3a2a20" />
          </div>
          <div class="hint">Auto from top band (darkest tones).</div>
        </div>
      </div>

      <div class="row">
        <button id="applyBtn">Apply to Avatar</button>
        <button id="resetBtn" title="Reload model">Reset</button>
      </div>

      <div class="sep"></div>

      <div>
        <strong>Material mapping</strong>
        <div class="hint">
          The code looks for materials named <code>Skin</code> and <code>Hair</code>.  
          Update your GLB or change names in the code if needed.
        </div>
      </div>

      <div class="sep"></div>

      <div>
        <strong>Rotate & zoom</strong>
        <div class="hint">Use mouse drag / wheel. Shift+drag to pan.</div>
      </div>
    </aside>
  </main>

  <footer style="padding:12px 16px; border-top:1px solid #1b2026;">
    <span class="hint">Tip: For best results, use a clear, well-lit selfie. Glasses/hats can bias hair detection.</span>
  </footer>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    // DOM elements
    const viewer = document.getElementById('viewer');
    const selfieInput = document.getElementById('selfieInput');
    const canvas = document.getElementById('selfieCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const skinColorInput = document.getElementById('skinColor');
    const hairColorInput = document.getElementById('hairColor');
    const applyBtn = document.getElementById('applyBtn');
    const resetBtn = document.getElementById('resetBtn');

    // THREE.js scene setup
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(viewer.clientWidth, Math.max(viewer.clientHeight, 480));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    viewer.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, renderer.domElement.width / renderer.domElement.height, 0.1, 100);
    camera.position.set(0, 1.5, 3.2);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x445566, 0.8);
    scene.add(hemi);
    const key = new THREE.DirectionalLight(0xffffff, 1);
    key.position.set(2, 4, 3);
    scene.add(key);
    const rim = new THREE.DirectionalLight(0xffffff, 0.5);
    rim.position.set(-2, 3, -3);
    scene.add(rim);

    // Ground for subtle shadow
    const ground = new THREE.Mesh(
      new THREE.CircleGeometry(5, 64),
      new THREE.MeshStandardMaterial({ color: 0x0c1116, metalness: 0, roughness: 1 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    // Load avatar model
    const loader = new GLTFLoader();
    let avatarRoot = null;
    const MODEL_URL = 'baseAvatar.glb'; // Place your GLB avatar model here

    async function loadModel() {
      if (avatarRoot) {
        scene.remove(avatarRoot);
        avatarRoot = null;
      }
      try {
        const gltf = await loader.loadAsync(MODEL_URL);
        avatarRoot = gltf.scene;
        // Adjust materials if necessary
        avatarRoot.traverse(obj => {
          if (obj.isMesh) {
            obj.castShadow = true;
            obj.receiveShadow = true;
            if (!(obj.material instanceof THREE.MeshStandardMaterial)) {
              obj.material = new THREE.MeshStandardMaterial({ color: obj.material?.color || 0xffffff });
            }
          }
        });

        // Center and scale model
        const box = new THREE.Box3().setFromObject(avatarRoot);
        const size = new THREE.Vector3();
        box.getSize(size);
        const center = new THREE.Vector3();
        box.getCenter(center);

        const scale = 1.6 / Math.max(size.x, size.y, size.z);
        avatarRoot.scale.setScalar(scale);
        avatarRoot.position.sub(center.multiplyScalar(scale));
        avatarRoot.position.y = 0;

        scene.add(avatarRoot);
      } catch (e) {
        alert('Error loading avatar model.');
        console.error(e);
      }
    }

    function rgbToHex(r, g, b) {
      return "#" + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      }).join('');
    }

    function hexToThreeColor(hex) {
      return new THREE.Color(hex);
    }

    // Clamp helper
    function clamp(v, min, max) {
      return Math.min(Math.max(v, min), max);
    }

    // Region average color function for selfie image
    function averageRegion(imgData, region) {
      const { data, width, height } = imgData;
      const { x, y, w, h, type } = region;
      const cx = x + w / 2,
        cy = y + h / 2;
      const rx = w / 2,
        ry = h / 2;

      const values = [];
      for (let j = Math.max(0, y); j < Math.min(height, y + h); j++) {
        for (let i = Math.max(0, x); i < Math.min(width, x + w); i++) {
          // ellipse mask check
          const dx = (i - cx) / rx;
          const dy = (j - cy) / ry;
          if (dx * dx + dy * dy > 1) continue;
          const idx = (j * width + i) * 4;
          const r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];
          if (a < 10) continue;
          const luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
          if (type === 'skin') {
            if (luma < 40 || luma > 240) continue;
            if (!(r > 80 && g > 40 && b > 20)) continue;
          } else if (type === 'hair') {
            if (luma > 160) continue;
          }
          values.push([r, g, b]);
        }
      }
      if (!values.length) return [200, 170, 150];
      const lum = values.map(([r, g, b]) => 0.2126 * r + 0.7152 * g + 0.0722 * b).sort((a, b) => a - b);
      const lo = lum[Math.floor(lum.length * 0.1)];
      const hi = lum[Math.floor(lum.length * 0.9)];
      let R = 0,
        G = 0,
        B = 0,
        n = 0;
      for (const [r, g, b] of values) {
        const L = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        if (L < lo || L > hi) continue;
        R += r;
        G += g;
        B += b;
        n++;
      }
      if (n === 0) return values[0];
      return [Math.round(R / n), Math.round(G / n), Math.round(B / n)];
    }

    async function estimateColorsFromSelfie(file) {
      const img = new Image();
      const url = URL.createObjectURL(file);
      await new Promise((res, rej) => {
        img.onload = res;
        img.onerror = rej;
        img.src = url;
      });

      // draw into square canvas
      const S = canvas.width;
      const scale = Math.max(S / img.width, S / img.height);
      const w = Math.round(img.width * scale);
      const h = Math.round(img.height * scale);
      const ox = Math.round((S - w) / 2);
      const oy = Math.round((S - h) / 2);
      ctx.clearRect(0, 0, S, S);
      ctx.drawImage(img, ox, oy, w, h);

      const imgData = ctx.getImageData(0, 0, S, S);

      const skinRegion = {
        x: Math.round(S * 0.20),
        y: Math.round(S * 0.15),
        w: Math.round(S * 0.60),
        h: Math.round(S * 0.70),
        type: 'skin'
      };

      const hairRegion = {
        x: Math.round(S * 0.10),
        y: Math.round(S * 0.02),
        w: Math.round(S * 0.80),
        h: Math.round(S * 0.28),
        type: 'hair'
      };

      const [sr, sg, sb] = averageRegion(imgData, skinRegion);
      const [hr, hg, hb] = averageRegion(imgData, hairRegion);

      const skinHex = rgbToHex(clamp(sr, 40, 245), clamp(sg, 30, 235), clamp(sb, 30, 230));
      const hairHex = rgbToHex(clamp(hr, 10, 110), clamp(hg, 10, 110), clamp(hb, 10, 110));

      skinColorInput.value = skinHex;
      hairColorInput.value = hairHex;

      URL.revokeObjectURL(url);
      return { skinHex, hairHex };
    }

    function applyColorsToAvatar(skinHex, hairHex) {
      if (!avatarRoot) return;
      let skinCount = 0,
        hairCount = 0;
      avatarRoot.traverse(obj => {
        if (obj.isMesh && obj.material) {
          const name = (obj.material.name || obj.name || '').toLowerCase();
          if (name.includes('skin')) {
            obj.material.color = hexToThreeColor(skinHex);
            obj.material.needsUpdate = true;
            skinCount++;
          } else if (name.includes('hair')) {
            obj.material.color = hexToThreeColor(hairHex);
            obj.material.needsUpdate = true;
            hairCount++;
          }
        }
      });
      if (skinCount + hairCount === 0) {
        alert('No materials named "Skin" or "Hair" found in model. Please check GLB.');
      }
    }

    selfieInput.addEventListener('change', async e => {
      if (!e.target.files.length) return;
      try {
        await estimateColorsFromSelfie(e.target.files[0]);
      } catch {
        alert('Failed to load selfie. Please try another image.');
      }
    });

    applyBtn.addEventListener('click', () => {
      applyColorsToAvatar(skinColorInput.value, hairColorInput.value);
    });

    resetBtn.addEventListener('click', async () => {
      await loadModel();
    });

    window.addEventListener('resize', () => {
      const w = viewer.clientWidth;
      const h = Math.max(viewer.clientHeight, 480);
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    });

    renderer.setAnimationLoop(() => {
      controls.update();
      renderer.render(scene, camera);
    });

    await loadModel();
    window.dispatchEvent(new Event('resize'));
  </script>
</body>
</html>
