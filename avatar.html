<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Selfie → Avatar (No AI)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --pad: 12px; }
    body {
      margin: 0; font-family: system-ui, Arial, sans-serif; background:#0b0d10; color:#e9eef3;
      display:flex; flex-direction:column; min-height:100dvh;
    }
    header { padding: var(--pad) calc(var(--pad) * 2); border-bottom:1px solid #1b2026; }
    main { display:grid; grid-template-columns: 1fr 340px; gap: 16px; padding: 16px; flex:1; }
    #viewer { background:#0f1318; border:1px solid #1b2026; border-radius:16px; min-height:60dvh; display:flex; align-items:center; justify-content:center; }
    #controls { background:#0f1318; border:1px solid #1b2026; border-radius:16px; padding: 16px; display:flex; flex-direction:column; gap:12px; }
    .row { display:flex; align-items:center; gap:10px; }
    .row input[type="color"] { width: 48px; height: 36px; border: none; background: transparent; }
    .hint { font-size: 12px; color:#9aa7b3; }
    button, label.btn {
      background:#1e2630; color:#e9eef3; border:1px solid #2a3542; padding:8px 12px; border-radius:10px;
      cursor:pointer; transition: transform .06s ease, background .2s ease;
    }
    button:hover, label.btn:hover { background:#222c39; }
    button:active, label.btn:active { transform: translateY(1px); }
    #selfieCanvas { display:none; }
    .swatch { width:16px; height:16px; border-radius:4px; border:1px solid #2a3542; display:inline-block; vertical-align:middle; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .sep { height:1px; background:#1b2026; margin:6px 0; }
    code { background:#0b0f14; padding:2px 6px; border-radius:6px; border:1px solid #161b21; }
    @media (max-width: 980px){ main { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <header>
    <h2>Selfie → Avatar (No AI / No External APIs)</h2>
    <div class="hint">Upload a selfie. We estimate skin & hair colors client-side and apply them to your GLB avatar.</div>
  </header>

  <main>
    <div id="viewer"></div>

    <aside id="controls">
      <div class="row" style="justify-content:space-between;">
        <div>
          <strong>1) Upload selfie</strong>
          <div class="hint">Frontal face, good light. JPG/PNG.</div>
        </div>
        <label class="btn" for="selfieInput">Choose file</label>
        <input id="selfieInput" type="file" accept="image/*" style="display:none;" />
      </div>

      <canvas id="selfieCanvas" width="512" height="512"></canvas>

      <div class="sep"></div>

      <div><strong>2) Detected colors</strong> <span class="hint">(you can tweak)</span></div>
      <div class="grid">
        <div>
          <div class="row">
            <label for="skinColor">Skin</label>
            <input id="skinColor" type="color" value="#f2d3c2" />
          </div>
          <div class="hint">Auto from central face region.</div>
        </div>
        <div>
          <div class="row">
            <label for="hairColor">Hair</label>
            <input id="hairColor" type="color" value="#3a2a20" />
          </div>
          <div class="hint">Auto from top band (darkest tones).</div>
        </div>
      </div>

      <div class="row">
        <button id="applyBtn">Apply to Avatar</button>
        <button id="resetBtn" title="Reload model">Reset</button>
      </div>

      <div class="sep"></div>

      <div>
        <strong>Material mapping</strong>
        <div class="hint">
          The code looks for materials named <code>Skin</code> and <code>Hair</code>.  
          Update your GLB or change names in the code if needed.
        </div>
      </div>

      <div class="sep"></div>

      <div>
        <strong>Rotate & zoom</strong>
        <div class="hint">Use mouse drag / wheel. Shift+drag to pan.</div>
      </div>
    </aside>
  </main>

  <!-- Hidden swatches preview (optional) -->
  <footer style="padding:12px 16px; border-top:1px solid #1b2026;">
    <span class="hint">Tip: For best results, use a clear, well-lit selfie. Glasses/hats can bias hair detection.</span>
  </footer>

  <!-- THREE.js & helpers from CDN (no bundler) -->
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    // ====== DOM ======
    const viewer = document.getElementById('viewer');
    const selfieInput = document.getElementById('selfieInput');
    const canvas = document.getElementById('selfieCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const skinColorInput = document.getElementById('skinColor');
    const hairColorInput = document.getElementById('hairColor');
    const applyBtn = document.getElementById('applyBtn');
    const resetBtn = document.getElementById('resetBtn');

    // ====== 3D Scene ======
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(viewer.clientWidth, Math.max(viewer.clientHeight, 480));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    viewer.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, renderer.domElement.width / renderer.domElement.height, 0.1, 100);
    camera.position.set(0, 1.5, 3.2);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x445566, 0.8);
    scene.add(hemi);
    const key = new THREE.DirectionalLight(0xffffff, 1.0);
    key.position.set(2, 4, 3);
    key.castShadow = false;
    scene.add(key);
    const rim = new THREE.DirectionalLight(0xffffff, 0.5);
    rim.position.set(-2, 3, -3);
    scene.add(rim);

    // Ground (subtle)
    const ground = new THREE.Mesh(
      new THREE.CircleGeometry(5, 64),
      new THREE.MeshStandardMaterial({ color: 0x0c1116, metalness: 0, roughness: 1 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    // ====== Load Avatar Model ======
    const loader = new GLTFLoader();
    let avatarRoot = null;
    const MODEL_URL = 'baseAvatar.glb'; // <- put your GLB next to this HTML

    function loadModel() {
      return new Promise((resolve, reject) => {
        loader.load(
          MODEL_URL,
          (gltf) => {
            avatarRoot = gltf.scene;
            avatarRoot.traverse(obj => {
              if (obj.isMesh) {
                obj.castShadow = true; obj.receiveShadow = true;
                // Ensure standard material with sRGB texture handling
                if (!(obj.material instanceof THREE.MeshStandardMaterial)) {
                  obj.material = new THREE.MeshStandardMaterial({ color: obj.material?.color || 0xffffff });
                }
                obj.material.roughness = Math.min(0.9, obj.material.roughness ?? 0.6);
                obj.material.metalness = Math.max(0.0, obj.material.metalness ?? 0.0);
              }
            });
            // Center and scale nicely
            const box = new THREE.Box3().setFromObject(avatarRoot);
            const size = new THREE.Vector3();
            box.getSize(size);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const scale = 1.6 / Math.max(size.x, size.y, size.z);
            avatarRoot.scale.setScalar(scale);
            avatarRoot.position.sub(center.multiplyScalar(scale));
            avatarRoot.position.y = 0; // feet on ground (approx)
            scene.add(avatarRoot);
            resolve();
          },
          undefined,
          (err) => reject(err)
        );
      });
    }

    // ====== Color Utilities ======
    function rgbToHex(r, g, b) {
      const toHex = (v) => ('0' + v.toString(16)).slice(-2);
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }
    function hexToThreeColor(hex) {
      return new THREE.Color(hex);
    }
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    // Average color over an elliptical region (exclude extremes to avoid highlights/shadows)
    function averageRegion(imgData, region) {
      const { data, width, height } = imgData;
      const { x, y, w, h, type } = region;
      const cx = x + w / 2, cy = y + h / 2;
      const rx = w / 2, ry = h / 2;

      const values = [];
      for (let j = Math.max(0, y); j < Math.min(height, y + h); j++) {
        for (let i = Math.max(0, x); i < Math.min(width, x + w); i++) {
          // ellipse mask
          const dx = (i - cx) / rx;
          const dy = (j - cy) / ry;
          if (dx*dx + dy*dy > 1) continue;

          const idx = (j * width + i) * 4;
          let r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];
          if (a < 10) continue;

          // simple skin/hair heuristics
          const luma = 0.2126*r + 0.7152*g + 0.0722*b;

          if (type === 'skin') {
            // reject very bright highlights & very dark shadows
            if (luma < 40 || luma > 240) continue;
            // mild skin-ish band (not strict)
            if (!(r > 80 && g > 40 && b > 20)) continue;
          } else if (type === 'hair') {
            // hair tends to be darker than mid-gray
            if (luma > 160) continue;
          }

          values.push([r, g, b]);
        }
      }
      if (!values.length) return [200, 170, 150]; // fallback warm skin

      // trim outliers (median-based)
      const lum = values.map(([r,g,b]) => 0.2126*r + 0.7152*g + 0.0722*b).sort((a,b)=>a-b);
      const lo = lum[Math.floor(lum.length*0.1)];
      const hi = lum[Math.floor(lum.length*0.9)];
      let R=0,G=0,B=0, n=0;
      for (const [r,g,b] of values) {
        const L = 0.2126*r + 0.7152*g + 0.0722*b;
        if (L < lo || L > hi) continue;
        R+=r; G+=g; B+=b; n++;
      }
      if (n === 0) return values[0];
      return [Math.round(R/n), Math.round(G/n), Math.round(B/n)];
    }

    async function estimateColorsFromSelfie(file) {
      const img = new Image();
      const url = URL.createObjectURL(file);
      await new Promise((resolve, reject) => {
        img.onload = () => resolve();
        img.onerror = reject;
        img.src = url;
      });

      // draw into square canvas
      const S = canvas.width;
      // cover-fit
      const scale = Math.max(S / img.width, S / img.height);
      const w = Math.round(img.width * scale);
      const h = Math.round(img.height * scale);
      const ox = Math.round((S - w) / 2);
      const oy = Math.round((S - h) / 2);
      ctx.clearRect(0,0,S,S);
      ctx.drawImage(img, ox, oy, w, h);

      const imgData = ctx.getImageData(0, 0, S, S);

      // Heuristic regions:
      // skin: center ellipse (face area) ~ 60% x 70%
      const skinRegion = {
        x: Math.round(S * 0.20),
        y: Math.round(S * 0.15),
        w: Math.round(S * 0.60),
        h: Math.round(S * 0.70),
        type: 'skin'
      };
      // hair: top band ellipse ~ 80% width x 30% height at top
      const hairRegion = {
        x: Math.round(S * 0.10),
        y: Math.round(S * 0.02),
        w: Math.round(S * 0.80),
        h: Math.round(S * 0.28),
        type: 'hair'
      };

      const [sr, sg, sb] = averageRegion(imgData, skinRegion);
      const [hr, hg, hb] = averageRegion(imgData, hairRegion);

      // Slightly clamp saturation for stability
      const skinHex = rgbToHex(clamp(sr, 40, 245), clamp(sg, 30, 235), clamp(sb, 30, 230));
      const hairHex = rgbToHex(clamp(hr, 10, 110), clamp(hg, 10, 110), clamp(hb, 10, 110));

      // update pickers
      skinColorInput.value = skinHex;
      hairColorInput.value = hairHex;

      URL.revokeObjectURL(url);
      return { skinHex, hairHex };
    }

    function applyColorsToAvatar(skinHex, hairHex) {
      if (!avatarRoot) return;
      let appliedSkin = 0, appliedHair = 0;
      avatarRoot.traverse(obj => {
        if (obj.isMesh && obj.material) {
          // If your GLB has material.name set to "Skin" and "Hair"
          const name = (obj.material.name || obj.name || '').toLowerCase();
          if (name.includes('skin')) {
            obj.material.color = hexToThreeColor(skinHex);
            obj.material.needsUpdate = true;
            appliedSkin++;
          } else if (name.includes('hair')) {
            obj.material.color = hexToThreeColor(hairHex);
            obj.material.needsUpdate = true;
            appliedHair++;
          }
        }
      });
      if (appliedSkin + appliedHair === 0) {
        console.warn('No materials named "Skin" or "Hair" were found. Please rename materials in your GLB.');
        alert('Heads up: Couldn’t find materials named "Skin" or "Hair" in the model.\nRename them in your GLB or adjust the code where it matches names.');
      }
    }

    // ====== Events ======
    selfieInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        await estimateColorsFromSelfie(file);
      } catch (err) {
        console.error(err);
        alert('Failed to read selfie. Try a different image.');
      }
    });

    applyBtn.addEventListener('click', () => {
      applyColorsToAvatar(skinColorInput.value, hairColorInput.value);
    });

    resetBtn.addEventListener('click', async () => {
      // Reload model cleanly
      if (avatarRoot) { scene.remove(avatarRoot); avatarRoot = null; }
      await loadModel();
    });

    // Resize handling
    function onResize() {
      const w = viewer.clientWidth;
      const h = Math.max(viewer.clientHeight, 480);
      renderer.setSize(w, h);
      camera.aspect = w / h; camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    // Animate loop
    renderer.setAnimationLoop(() => {
      controls.update();
      renderer.render(scene, camera);
    });

    // Boot
    await loadModel();
    onResize();

  </script>
</body>
</html>


